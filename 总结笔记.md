# 1.Two sum #HashMap
遇到检索具有某些特征值的时候需要考虑使用hashmap来减少搜索的时间成本

Hashmap的搜索速率能达到nlogn

# 5.Longest-palindromic #DP
动规问题要先想清楚其中的递推关系, 想明白2d储存还是1d, 根据递推关系来找出合理的遍历顺序

# 15.Three Sum # Twopointer

除了正常使用hashmap来进行对特征值进行搜索, 可以善用排序来对于原数据进行优化, 本题采用two pointer的方法来控制遍历

本题核心是要通过对于条件的达成情况来决策正在遍历的值的所有可能的答案都以及被找到了

# 17 Letter Combinations of a Phone Number #DFS

本质上为就是使用递归中的深度优先算法, 加上回溯记忆也就是让其之前的已经组好的字符串传入下一次运算, 以此减少重复计算量.

# 18 Four Sum #Twopointer

整体解法与three sum相同只不过在外层额外添加一层for循环来达成4个pointer进行的整体遍历

# 19 Remove nth Node From End of List #Twopointer

本题主要要通过一次遍历来完成删除, 只需要设定两个pointer, 一个先开始遍历, 另外一个慢一点, 两个pointer之间正好相隔n个距离, 这样当快pointer到达尾部, 慢pointer也正好到达需要删除的位置, 只需通过一边遍历就可完成删除

# 20 Vaild parentheses #Stack

由于括号的对称性, 因此使用stack来进行检测最为便捷

# 24 Swap Nodes in Pairs #Twopointer
这道题不难只需要用考虑好结束条件并且使用四个pointer来进行来回倒腾就可以做出来, 没有什么难度, 只需要画图模拟并明确pointer位置的变换, 基本这道题就可以被做出来了

# 27 Remove Element # Twopointer
本题要求去除list中的特定element, 因此只需要用快慢指针, 一个在前面进行扫描, 第二个再后面重新写入一遍不是要删除的element, 复杂度只需要O(n)就可以完成

# 28 Find the index of the First Occurrence in a String #KMP
本题使用到了经典的string匹配中的KMP算法, 其中kmp算法的目的是为了节省无用的回溯, 使用kmp算法复杂度可以达到O(m+n).

其中需要使用next数组来确保回溯位置, 而next数组中所记录的就是最大相等前后缀的长度, 首先先来解释下前后缀分别是什么, 前缀的字符串是从开始的第一个字符到倒数第二个字符的所有可能性(不包括最后一个字符 eg. abc prefix: a, ab)的, 同理后缀是从倒数第一个字符到正数第二个字符串的所有可能性(eg, abc, c, bc), 所有前后缀都是从左向右读出来的, 并不是回文形式! 

首先next数组有多种不同的写法, 每一种都不太一样, 但本质计算过程是一样的, 我采用的则是0开头的一种. 首先数组的初始话为0, 因为一个字符没有前后缀因此只能为0. 在此以ABACABABA对应的next数组为

[A, B, A, C, A, B, A, B, A]

[0,  0,  1,  0,  1,  2,  3,  2]

首先计算每一个字符的最大相等前后缀, 第一个字符为特殊初始值为0, 之后使用twopointer的方法进行计算, 首先p1, p2分别开始移动, 如果p1的值等于p2的值的话, 则将p2-1的值加一之后作为p2的值, 之后将p1 p2都向后挪一位. 如果p1不等于p2的话, 情况则比较复杂, 需要进行递归查询一直找到之前有记录的最长前后缀的位置, 由于next数组记录的就是回溯位置因此可以直接利用, 直接查看p1-1的值并将其储存进拍p3, 之后比较p2和p3 如果说p2等于p3的话, 那么p2的值将会是p1-1的值加一. 如果p2和p3不相等的话, 那么将一直向前寻找直到找到字符串的开头, 如果连开头都没有匹配上的话那么, p2位置填入0 代表着, p2这个值和之前的值没有任何相等的前缀, 只能从头匹配. 

这样我们已经讲完了next数组的计算, 同意在里面也已经使用过了数字, 在这里再次说明next数组中的数字的含义已经如何使用. 首先如果next数组是存有每一个子串的最长相等前后缀的位置, 假如说我们p1和p2分别指向目标串和匹配串(目标串是长的包含匹配串), 当p1的值不等于p2的值, 那么next数组中p2-1的位置就是其需要回溯的index, 因此p2将直接等于p2-1的值. 

接下来讲一下那么怎么利用next数组进行匹配, 使用的方法非常类似, 同样使用twopointer的方法, p1和p2分别指向目标串和匹配串. 如果p1的值等与p2的值, 那么p1和p2同时向后移(也就是+1), 如果遇到不相等的情况, 那么p2就会去找next[p2-1]所储存的值来进行回溯. 那么如何判断是否有符合的字符串呢, 有两种可能第一p1从头遍历到尾, 也没有找到串, 二 就是p2变成了匹配串的长度, 那么也就代表着说最后一个匹配串的字符也已经相等, 也就是说在目标串中找到了匹配串.

整体来讲可以通过优化p3已经不使用forloop来让代码变得更加间接, 逻辑更加清楚.






